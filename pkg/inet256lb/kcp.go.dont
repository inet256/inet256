package inet256lb

import (
	"context"
	"net"

	"github.com/inet256/inet256/pkg/inet256"
	kcp "github.com/xtaci/kcp-go/v5"
)

type kcpFrontend struct {
	pc net.PacketConn
	l  *kcp.Listener
}

func NewKCPFrontend(node inet256.Node) (StreamEndpoint, error) {
	pc := inet256.NewPacketConn(node)
	bc, err := kcp.NewNoneBlockCrypt(nil)
	if err != nil {
		panic(err)
	}
	l, err := kcp.ServeConn(bc, 1, 0, pc)
	if err != nil {
		return nil, err
	}
	return &kcpFrontend{
		pc: pc,
		l:  l,
	}, nil
}

func (fe *kcpFrontend) Open(ctx context.Context) (net.Conn, error) {
	return fe.l.Accept()
}

func (fe *kcpFrontend) Close() error {
	return fe.l.Close()
}

type kcpBackend struct {
	pc     net.PacketConn
	target inet256.Addr
}

func NewKCPBackend(node inet256.Node, target inet256.Addr) StreamEndpoint {
	pc := inet256.NewPacketConn(node)
	return &kcpBackend{
		pc:     pc,
		target: target,
	}
}

func (be *kcpBackend) Open(ctx context.Context) (net.Conn, error) {
	bc, _ := kcp.NewNoneBlockCrypt(nil)
	return kcp.NewConn2(be.target, bc, 1, 0, be.pc)
}

func (be *kcpBackend) Close() error {
	return nil
}

// // ListenKCP uses node to listen for KCP connections.
// func ListenKCPMux(node inet256.Node) (*KCPMuxListener, error) {
// 	bc, err := kcp.NewNoneBlockCrypt(nil)
// 	if err != nil {
// 		panic(err)
// 	}
// 	l, err := kcp.ServeConn(bc, 1, 0, inet256.NewPacketConn(node))
// 	if err != nil {
// 		return nil, err
// 	}
// 	return (*KCPMuxListener)(l), nil
// }

// type KCPMuxListener kcp.Listener

// func (l *KCPMuxListener) Accept() (*KCPMuxSession, error) {
// 	c, err := (*kcp.Listener)(l).AcceptKCP()
// 	if err != nil {
// 		return nil, err
// 	}
// 	c.SetMtu(inet256.MinMTU)
// 	sess, err := smux.Server(c, nil)
// 	if err != nil {
// 		return nil, err
// 	}
// 	return &KCPMuxSession{conn: c, Session: sess}, nil
// }

// func (l *KCPMuxListener) Close() error {
// 	return (*kcp.Listener)(l).Close()
// }

// // DialKCP uses node to dial an outbonud KCP connection raddr.
// func DialKCPMux(node inet256.Node, raddr inet256.Addr) (*KCPMuxSession, error) {
// 	bc, _ := kcp.NewNoneBlockCrypt(nil)
// 	c, err := kcp.NewConn3(0, raddr, bc, 1, 0, inet256.NewPacketConn(node))
// 	if err != nil {
// 		return nil, err
// 	}
// 	c.SetMtu(inet256.MinMTU)
// 	sess, err := smux.Client(c, nil)
// 	if err != nil {
// 		return nil, err
// 	}
// 	return &KCPMuxSession{conn: c, Session: sess}, nil
// }

// type KCPMuxSession struct {
// 	conn *kcp.UDPSession
// 	*smux.Session
// }
