package dns256

import (
	"bytes"
	"encoding/json"
	"net/netip"

	"go.brendoncarroll.net/tai64"
	"go.inet256.org/inet256/src/inet256"
)

// RequestID is a random ID assigned to a request.
// It is generated by clients, and used by servers to respond to a request
type RequestID [16]byte

func (id RequestID) MarshalJSON() ([]byte, error) {
	return json.Marshal(id[:])
}

func (id *RequestID) UnmarshalJSON(x []byte) error {
	var s []byte
	if err := json.Unmarshal(x, &s); err != nil {
		return err
	}
	copy(id[:], s)
	return nil
}

// Request is sent by clients to retrieve records from a server.
type Request struct {
	ID    RequestID `json:"id"`
	Query Query     `json:"query"`
}

// Query describes a set of records that the client is interested in.
type Query struct {
	Path Path `json:"path"`

	Filter Predicate `json:"filter,omitempty"`
}

func (q Query) Matches(r Record) bool {
	return q.Filter.Matches(r)
}

// Predicate matches a set of records
type Predicate struct {
	And    []Predicate     `json:"and,omitempty"`
	Or     []Predicate     `json:"or,omitempty"`
	Exact  *PredicateExact `json:"exact,omitempty"`
	HasKey *string         `json:"has_key,omitempty"`
}

func (p Predicate) Matches(r Record) bool {
	switch {
	case p.And != nil:
		for _, p2 := range p.And {
			if !p2.Matches(r) {
				return false
			}
		}
		return true
	case p.Or != nil:
		for _, p2 := range p.Or {
			if p2.Matches(r) {
				return true
			}
		}
		return false
	case p.Exact != nil:
		return p.Exact.Matches(r)
	case p.HasKey != nil:
		_, exists := r[*p.HasKey]
		return exists
	default:
		return true
	}
}

// PredicateExact only matches records where a key has an exact value
type PredicateExact struct {
	Key   string          `json:"key"`
	Value json.RawMessage `json:"value"`
}

func (p PredicateExact) Matches(r Record) bool {
	return bytes.Equal(r[p.Key], p.Value)
}

// MustHaveKeys returns a Predicate which only matches records which have keys for all of ks.
func MustHaveKeys(ks ...string) Predicate {
	var ps []Predicate
	for _, k := range ks {
		ps = append(ps, Predicate{
			HasKey: &k,
		})
	}
	return Predicate{
		And: ps,
	}
}

// Response is returned by servers in response to requests
type Response struct {
	// RequestID is the ID of the corresponding Request
	RequestID RequestID `json:"req_id"`
	// Now is the server time
	Now tai64.TAI64 `json:"now"`

	// IsRedirect is true if the response is a redirect
	IsRedirect bool `json:"is_redirect"`
	// Claims are the claims that the server is making about Records
	Claims []Claim `json:"claims"`
}

// Record is the unit of information in DNS256
type Record map[string]json.RawMessage

func (r Record) String() string {
	data, _ := json.Marshal(r)
	return string(data)
}

func (r Record) AsUint64(key string) (uint64, error) {
	return jsonParse[uint64](r[key])
}

func (r Record) AsUint16(key string) (ret uint16, _ error) {
	return jsonParse[uint16](r[key])
}

func (r Record) AsString(key string) (ret string, err error) {
	return jsonParse[string](r[key])
}

func (r Record) AsINET256(key string) (ret inet256.Addr, err error) {
	return jsonParse[inet256.Addr](r[key])
}

func (r Record) AsIP(key string) (netip.Addr, error) {
	s, err := r.AsString(key)
	if err != nil {
		return netip.Addr{}, err
	}
	return netip.ParseAddr(s)
}

func (e Record) AsIPPort(key string) (netip.AddrPort, error) {
	s, err := e.AsString(key)
	if err != nil {
		return netip.AddrPort{}, err
	}
	return netip.ParseAddrPort(s)
}

func (e Record) AsBytes(key string) (ret []byte, _ error) {
	return ret, json.Unmarshal(e[key], &ret)
}

func (e Record) AsPath(key string) (ret Path, _ error) {
	return ret, json.Unmarshal(e[key], &ret)
}

func (e Record) AsRedirect() (*RedirectINET256, error) {
	path, err := e.AsPath("path")
	if err != nil {
		return nil, err
	}
	target, err := e.AsINET256("target")
	if err != nil {
		return nil, err
	}
	return &RedirectINET256{Path: path, Target: target}, nil
}

type RedirectINET256 struct {
	Path   Path
	Target inet256.Addr
}

func (r RedirectINET256) ToRecord() Record {
	return Record{
		"path":   NewValue(r.Path),
		"target": NewValue(r.Target),
	}
}

// A Claim is a Record paired with a TTL
type Claim struct {
	Record Record `json:"record"`
	// TTL is the time to live in seconds
	TTL uint32 `json:"ttl"`
}

func NewValue(x any) json.RawMessage {
	data, err := json.Marshal(x)
	if err != nil {
		panic(err)
	}
	return data
}

func jsonParse[T any](x json.RawMessage) (ret T, _ error) {
	return ret, json.Unmarshal(x, &ret)
}
